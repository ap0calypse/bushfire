#!/usr/bin/perl
use strict;
use Curses;
use Time::HiRes qw(usleep);


# name:     bushfire
# author:   Manuel Fill (ap0calypse@agitatio.org)
# license:  if not specified, it's under GPL

my $area;

print "Welcome to bushfire!\n" .
      "The program needs some information now:\n\n";

print "How long should the area be? (leave blank for maximum): ";
chomp(my $length = <STDIN>);
print "How high should the area be? (leave blank for maximum): ";
chomp(my $height = <STDIN>);
print "Maximum level for vegetation (lower means easier burn-able, leave blank for default; default is 7): ";
chomp(my $max_veg = <STDIN>);
print "Percentage for starting a fire (leave blank for default; default is 1): ";
chomp(my $percentage = <STDIN>);
print "Microseconds between screen refreshs (leave blank for default; default is 100000): ";
chomp(my $microsecs = <STDIN>);

$max_veg = 7 if $max_veg !~ m/\d+/;
$microsecs = 100000 if $microsecs !~ m/\d+/;
$percentage = 1 if $percentage !~ m/\d+/;

initscr;
if($length eq "" || $length > $COLS - 2) { $length = $COLS - 2; }
if($height eq "" || $height > $LINES - 3) { $height = $LINES - 3; }

for my $x (1 .. $length) {
    for my $y (1 .. $height) {
        $area->{"$x:$y"} = int rand($max_veg) + 1;
    }
}

sub print_area {
    my $cycle = shift;
    clear;
    noecho;

    start_color;
    init_pair(1, COLOR_RED, COLOR_BLACK); # ACTIVE FIRE
    init_pair(2, COLOR_BLACK, COLOR_BLACK); # GLOWING AFTER FIRE
    init_pair(3, COLOR_YELLOW, COLOR_BLACK); # PLANTS soon burning
    init_pair(4, COLOR_GREEN, COLOR_BLACK); # PLANTS
    my $win = newwin($height + 2, $length + 2, 0, 0);
    box($win,0,0);
    my ($f, $f_b, $f_0, $f_1, $f_2, $f_3) = (0,0,0,0,0,0);
    for my $coords (keys %{$area}) {
        $f++;
         if ($area->{$coords} == 0) { # burn motherfucker .. burn
            $f_0++;
            attron($win,COLOR_PAIR(1));
            attron($win,A_BOLD);
            my ($x, $y) = split /:/, $coords;
            addstr($win, $y, $x, "~");
            attroff($win,A_BOLD);
            attroff($win,COLOR_PAIR(1));
         }
         elsif ($area->{$coords} < 0) { # empty, burned field 
            $f_b++;
            attron($win,COLOR_PAIR(2));
            my ($x, $y) = split /:/, $coords;
            addstr($win, $y, $x, "");
            attroff($win,COLOR_PAIR(2));
         }
         elsif ($area->{$coords} == 1) { # small vegetation very likely to burn
            $f_1++;
            attron($win,COLOR_PAIR(3));
            my ($x, $y) = split /:/, $coords;
            addstr($win, $y, $x, ".");
            attroff($win,COLOR_PAIR(3));
         }
         elsif ($area->{$coords} > 1 && $area->{$coords} < 5) { # normal vegetation
            $f_2++;
            attron($win,COLOR_PAIR(4));
            my ($x, $y) = split /:/, $coords;
            addstr($win,$y, $x, ":");
            attroff($win,COLOR_PAIR(4));
         }
         else { # heavy rainforest, very unlikely to burn
            $f_3++;
            attron($win,COLOR_PAIR(4)); 
            attron($win,A_BOLD);
            my ($x, $y) = split /:/, $coords;
            attroff($win,A_BOLD);
            addstr($win, $y, $x, "|");
            attroff($win,COLOR_PAIR(4));
         }
    }
    attron(COLOR_PAIR(1));
    addstr($win, 0,2 , "| Cycle: $cycle | Fields: $f | Burning: $f_0 | " .
                       "Burnt: $f_b | grass fiels: $f_1 | shrub fields: $f_2 | tree fields $f_3 |");
    attroff(COLOR_PAIR(1));
    refresh($win);
    doupdate;
}

my $cy = 0;

sub start_fire {
    my @burnables;
    for (keys %{$area}) {
        if ($area->{$_} == 1) {
            push @burnables, $_;
        }
    }
    my $random = rand scalar @burnables;
    $area->{$burnables[$random]}-- if defined $area->{$burnables[$random]};
}

while (1) {
    $cy++;
    if (int rand(100) < $percentage) { # possibility of starting a fire ( 2 % )
        &start_fire;
    }
    my @decrement;
    for my $coords (keys %{$area}) {
        if ($area->{$coords} == 0) {
            my ($x, $y) = split /:/, $coords;
            my ($l_x, $u_x, $l_y, $u_y) = ($x-1,$x+1,$y-1,$y+1);
            for my $X ($l_x .. $u_x) {
                for my $Y ($l_y .. $u_y) {
                    $area->{"$X:$Y"}-- if defined $area->{"$X:$Y"};
                    push @decrement, "$X:$Y" if defined $area->{"$X:$Y"};
                }
            }
        }
        if (($cy%100) == 0) { # plants grow, and die
            $area->{$coords} += (int rand(3)) if $area->{$coords} > 0 && $area->{$coords} < $max_veg;
            $area->{$coords} = (int(rand 2) + 1) if $area->{$coords} < 0;
            $area->{$coords} -= (int rand($max_veg)) if $area->{$coords} >= $max_veg;
        }
    }
    for (@decrement) { # burn it down
        $area->{$_}-- if $area->{$_} > 0;
    }
    &print_area($cy);
    usleep($microsecs);
}

